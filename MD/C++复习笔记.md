## 抛出异常

​     

```c++
throw <表达式>;
```

​    **注意：当一个异常被一个函数引发后，执行流程返回到该函数的调用者中。**

```c++
double Div(double a,double b){

　　　if (b==0.0) throw 1.0E-38;  return a/b;

　　}
```

## 检查异常

  

```c++
 try{
   可能发生异常的语句；
   }
```

 **注意：**

**（1） try块的语句在执行过程中可能会发生多种类型的异常，由catch块进行捕获并处理；**

**（2） 异常发生后，执行流程立即转到catch块，执行异常处理。**

## 异常捕获并处理

```c++
catch (类型 变量1){

　　　异常处理语句1；

　　}


　　catch (<参数声明n>){

　　　异常处理语句n；

　　}
```

**注意：（1）每个catch块声明了所要捕获的一种类型。**

**（2）catch语句块可以很多，但是最多只有一个catch语句块被执行。**



## 带默认参数的函数

**按从左到右的次序将实参和形参结合**

```c++
 int add(int x,int y=10);

//      add(15);　->　　add(15,10);


```

**注意:默认形参值必须由右向左的顺序定义。**

**如果某个参数有默认值，则其右面的参数必须都有默认值；如果某个参数没有默认值，则其左面的参数都不能有默认值。**

```c++
int  max(int a, int b=10, int c=20);            //正确

int  max(int a, int b=10, int c);                  //错误

int  max(int a=5, int b, int c=30);              //错误

//在后两种情况下，调用语句 x = max(20, 30); 会出错！
```

**注意2：在使用带默认参数值的函数时，只能在函数定义或函数声明中的一个位置给出默认值，不能在两个位置同时给出。----不能重复给出默认值**

**注意3：还要保证在函数调用之前给出默认值。**

**注意4:一个函数既是重载函数，又带默认参数，调用中会可能会出现二义性。**

```c++
int add(int x=5, int y=6) {return x+y; } 
float add(int x=5, float y=10.0) { return x+y; } 
int main() {

int a; float b;       a= add(10,20); 

b= add(10); 	//本句产生二义性,重载函数的第一个参数是int型无法区分

return 0;     
}
```

## 引用:实质是被引用变量(对象)的地址

**引用是变量的别名。**

引用与其“引用”的变量**公用一个存储空间**，不单独占用存储空间，并且引用的类型和其“引用”的变量的类型保持一致。

```c++
类型说明符  &引用名 ＝ 变量名；

int  a = 1;     int  &b = a;//引用的类型和原变量的类型保持一致
//b是a的别名,定义b的同时就要进行初始化
```

**注意:函数不能返回对局部变量(对象)的引用**

**函数内部初始化的局部变量(对象),在函数结束后就可能被销毁了,因此不能返回**

## 内联函数 inline

内联函数与一般函数的区别在于它不是在调用时发生控制转移，而是在编译时将被调函数体嵌入到每一个函数调用处，节省了参数传递、控制转移等开销。

内联函数的定义

```c++
inline  类型说明符  函数名（参数及类型表{             
函数体           
}
　　inline int add(int x,int y,int z)
　　{
　　　return x+y+z;
}
```

  

```c++
inline int f(int x){return x*x;}
int main(){
int x(2);
cout<<f(x)<<;”;
cout<<f(x+1)<<endl;
return 0;
}
/*
程序运行结果：
4;9
原因：
f(x)  替换为  2*2
f(x+1)  替换为  3*3
    inline相比于define,在语句之间多了括号
 */
 //---------------------------------------------   
#define f(x) x*x
int main(){
    int x(2);
    cout<<f(x)<<“;”;
    cout<<f(x+1)<<endl; return 0;
}
/*
程序运行结果：
4;5
原因：
f(x)	替换为2*2
f(x+1) 替换为2+1*2+1
*/
```

## 作用域运算符

直接用在全局函数前，表示是全局函数。当类的成员函数跟类外的一个全局函数同名时，在类内定义的时候，打此函数名默认 调用的是本身的成员函数；如果要调用同名的全局函数时，就必须打上::以示区别。

```c++
float a = 13.5;

int main(){

int a = 5;

std::cout<<a<<std::endl;       // 输出局部变量

std::cout<<::a<<std::endl;    //::a 输出全局变量

return 0;

} 
```

## 动态分配/撤销内存

new操作符动态分配内存建立的变量，称为“堆对象”或者“在动态存储中分配”。new运算符创建的堆对象一直存在，直到使用delete运算符显示的销毁。

```c++
new <类型说明符> (<初始值列表>)
int *p1 = new int(5);
delete p1;
int *p2 = new int[5];
delete [] p2;	//销毁动态创建的数组
```

**注意:
new运算符返回一个与new所分配对象类型相匹配的指针；**
**如果new运算符不能分配到所需要的内存，将返回0，这时为空指针**。

## 访问修饰符

| 访问修饰符 | 访问范围       | 继承性           |
| :--------- | :------------- | :--------------- |
| private    | 本类内部       | 不可继承         |
| default    | 本类+同包      | 同包子类可以继承 |
| protected  | 本类+同包+子类 | 可以继承         |
| public     | 公开           | 可以继承         |

类也可以由struct关键字声明，strust与class的区别是：
**如果不指定访问权限，struct缺省的访问权限是公有的，而class是私有的。**



## 类的成员函数

### 内联成员函数 

将成员函数的定义直接写在类中即成为内联成员函数，或者在类外定义时用inline指出。如：

```c++
inline void CRect::SetColor(string)
{
   color = c;
}  //内联成员函数
```

### 带默认参数值的成员函数

```c++
void SetSize(int l=100, int w=100);//声明

void CRect::SetSize(int l=100, int w=100){
        length=l; width = w;
    }	//定义

//默认参数只能在声明或定义中的一处给出,二者选一
```

### 构造函数

**特点:**

1.  构造函数的函数名与类名相同。
2. 不能定义构造函数的类型（即不能指明构造函数返回值的类型）。
3.  构造函数应声明为公有函数。
4.  构造函数不能在程序中调用，在对象创建时，构造函数被系统自动调用。 

如果类中没有构造函数，则系统会自动生成函数体为空的默认构造函数。

### 析构函数

**在删除一个对象前被调用，释放该对象成员的内存空间，以及其它一些清理工作。**

**特点:**

1.  析构函数名字为符号“~”加类名。 
2.  析构函数没有参数，不能指定返回值类型。      
3. 一个类中只能定义一个析构函数，所以析构函数不能重载。
4. 当一个对象作用域结束时或者使用delete运算符释放new运算符创建的对象时，系统自动调用析构函数。

如果类中没有提供析构函数，系统会自动生成一个函数体为空的析构函数。

**注意:**

**先创建的对象后调用析构函数**
**后被创建的对象先调用析构函数**
**简称为“先构造后析构，后构造先析构”**

#### 拷贝构造函数

用一个已经存在的对象初始化新对象，拷贝构造函数的**参数为该类对象的引用**。

```c++
类名::类名(const 类名&  引用名)
point::point(const point& p);
```

**注意：**

**每个类都必须有一个拷贝构造函数；[重要]**
**如果类中没有说明拷贝构造函数，则编译系统自动生成一个具有上述形式的默认拷贝构造函数，依次完成类中对应数据成员的拷贝。**